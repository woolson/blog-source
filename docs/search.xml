<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[在Sublime vim模式中配置Line-jump单键快捷键]]></title>
    <url>%2F2018%2F09%2F18%2Fvim-line-jumper%2F</url>
    <content type="text"><![CDATA[vim模式下有快捷键翻页，翻半页的快捷键，但是有时候我们并不想跳俺么多行。所以就找了个跳行的插件123456789101112131415161718安装了```package control```的同学可以直接在里面直接安装，没安装```package control```的同学先安装一下吧。^_^下面放配置方法吧，之前自己在配快捷键的时候在insert模式下也是跳行，导致快捷键字母键无法输入。```json&#123; &quot;keys&quot;: [&quot;m&quot;], &quot;command&quot;: &quot;line_jumper&quot;, &quot;context&quot;: [ &#123; &quot;key&quot;: &quot;setting.command_mode&quot;, &quot;operand&quot;: true &#125;, ], &quot;args&quot;: &#123; &quot;number_of_lines&quot;: 10, &quot;cmd&quot;: &quot;up&quot;, &quot;insert_mode&quot;: false &#125;&#125; 这个是在vim模式下按m键可以往上跳10行。主要是里面的insert_mode需要设置为false。往下跳行也是同理。 其实配置很简单，只是一直没找到配置项。找了很久，在此记录一下。]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减少nvm对shell启动速度的影响]]></title>
    <url>%2F2018%2F07%2F02%2Fspeed-up-shell%2F</url>
    <content type="text"><![CDATA[从事前端开发或者 nodejs 开发，难免遇到 nodejs 多版本切换。如果使用官方的 pkg 安装的话，切换版本比较麻烦。目前有两个比较热门的版本切换工具: n 和 nvm。 问题使用 nvm 后，发现一个问题，每次创建一个新窗口的时候，发现shell启动的比较慢。查看github的 issue 后作者解释就是创建的时候受 nvm.sh 的影响，在脚本中 nvm use default 版本这一步比较耗费时间。 解决所以作者建议对启动速度比较在意的人，在 &quot;$NVM_DIR/nvm.sh&quot; 后面加上 --no-use设置以禁止启动的时候 nvm use default 减少启动的速度。但是这样造成在用node之前需要先nvm use 这样执行一下。查看了 nvm github 有个大神建议修改配置如下： 123456# nvmexport NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh" --no-use # This loads nvmalias node='unalias node ; unalias npm ; nvm use default ; node $@'alias npm='unalias node ; unalias npm ; nvm use default ; npm $@' 启动时--no-use 在你使用 node 命令的时候在去做 nvm use default 操作。666]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS上使用zsh]]></title>
    <url>%2F2018%2F06%2F29%2Fmac-terminal%2F</url>
    <content type="text"><![CDATA[mac自带的 terminal.app 默认使用的是 bash 在使用起来不太舒服，比如：自动大小写转换、跳转目录、git仓库的信息…等等。zsh 能在各方面上对其碾压（后面细说）。再说mac自带的termianl.app虽然用上去还可以，推荐一款软件iTerm.app 来搭配 zsh 使用。这款软件对比terminal软件上，优势在于他的分屏功能、插件和主题(oh-my-zsh更优秀)。 zsh介绍zsh 是一款功能强大的 shell 软件，它可以兼容 bash，并且提供了很多高效的改进： 更好的自动补全 更好的文件名展开 强大的定制性 首先先看看当前系统中有哪些可以使用的终端：cat /etc/shells我的电脑中显示如下： 123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh zsh安装Mac系统自带了zsh, 一般不是最新版。使用 homebrew 安装最新版，执行命令: 1234# 安装zshbrew install zsh# 把zsh设为默认chsh -s /bin/zsh oh-my-zsh Oh My Zsh是一个令人愉快的开源社区驱动框架，用于管理您的zsh配置。它捆绑了大量有用的功能，助手，插件，主题以及一些让你惊叹的东西。 安装 oh-my-zsh1234567891011121314151617181920212223242526272829# curl/wget 二选一即可# via curl$ sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"# via wget$ sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"# 安装过程输出Cloning Oh My Zsh...Cloning into '/root/.oh-my-zsh'...remote: Counting objects: 712, done.remote: Compressing objects: 100% (584/584), done.remote: Total 712 (delta 15), reused 522 (delta 4), pack-reused 0Receiving objects: 100% (712/712), 443.58 KiB | 27.00 KiB/s, done.Resolving deltas: 100% (15/15), done.Checking connectivity... done.Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrcCopying your current PATH and adding it to the end of ~/.zshrc for you.Time to change your default shell to zsh! __ __ ____ / /_ ____ ___ __ __ ____ _____/ /_/ __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed! Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh. 这样，oh-my-zsh安装成功了，可以打开一个新的命令行标签页查看效果。 设置配置设置配置文件在 ~/.zshrc (当前登录用户根目录) 使用vim或其他编辑器打开。 12345678910111213141516171819202122232425262728293031323334# If you come from bash you might have to change your $PATH.# export PATH=$HOME/bin:/usr/local/bin:$PATH# Path to your oh-my-zsh installation.export ZSH=$HOME/.oh-my-zsh# Set name of the theme to load. Optionally, if you set this to &quot;random&quot;# it&apos;ll load a random theme each time that oh-my-zsh is loaded.# See https://github.com/robbyrussell/oh-my-zsh/wiki/ThemesZSH_THEME=&quot;robbyrussell&quot;# Would you like to use another custom folder than $ZSH/custom?# ZSH_CUSTOM=/path/to/new-custom-folder# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=(git)source $ZSH/oh-my-zsh.sh# User configuration# export MANPATH=&quot;/usr/local/man:$MANPATH&quot;# ssh# export SSH_KEY_PATH=&quot;~/.ssh/rsa_id&quot;# Example aliases# alias zshconfig=&quot;mate ~/.zshrc&quot;# alias ohmyzsh=&quot;mate ~/.oh-my-zsh&quot;...# 更多默认设置 ~/.oh-my-zsh/templates/zshrc.zsh-template 主题设置~/.zshrc 文件中修改 ZSH_THEME=&quot;robbyrussell&quot; 默认使用的是 robbyrussell。主题文件放在 ~/.oh-my-zsh/themes 文件夹下面。 主题样式可见： https://github.com/robbyrussell/oh-my-zsh/wiki/Themes 可以网上下载别人的主题文件放入 ~/.oh-my-zsh/themes/hello.zsh-theme。然后启用主题 ZSH_THEME=&quot;hello&quot;。 插件设置~/.zshrc 文件中修改 plugins=(git) 默认启用 git。如需启用更多插件，可加入需启用插件的名称，如下: plugins=(rails git textmate ruby lighthouse)。 推荐一款插件 zsh-syntax-highlighting（命令语法高亮) https://github.com/zsh-users/zsh-syntax-highlighting 更多插件 https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins https://github.com/unixorn/awesome-zsh-plugins https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview 目录别名/命令别名（alias）目录别名 如果我想在命令行中用sublime text打开某个文件: 123456789# sublime textalias st="/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl"# vscodealias vs="/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code"# 打开文件$ st ./index.js# 打开文件夹$ st ./src/ 组合命令，可以为git各种命令行操作配置别名。 123456789# 配置sthostalias sthost="st /etc/hosts"# 输入sthost即可完成使用sublime打开host文件$ sthost# git·命令alias gl="git clone"alias ga="git add"alias gac="ga . &amp;&amp; gcm" 目录别名 1234# 配置目录别名alias projects="/Users/hello/Documents/Files/projects"# 不管你在任何目录，cd projects 即可到达$ cd projects 目录跳转有个更出名的插件：autojump。【强大的一批】 12345678# 安装autojump$ brew install autojump# 配置别名alias j="autojump"# 使用$ autojump some-folder$ j some-folder 卸载 oh-my-zsh直接在终端中，运行 uninstall_oh_my_zsh 即卸载。 12# 卸载$ uninstall_oh_my_zsh 完事到这就差不多了，后面有好东西再做更新。]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用eslint VScode错误提示和保存修复]]></title>
    <url>%2F2018%2F06%2F07%2Feslint-in-vue%2F</url>
    <content type="text"><![CDATA[什么是 eslint任何两个程序猿代码风格不可能一模一样的（不抬杠）。例如： 123456789// 程序猿Afunction getName ()&#123;&#125;// 程序猿Bfunction get_name() &#123;&#125; &ensp;&ensp;&ensp;&ensp;其实这两个代码都能够正常运行，不会有问题。但是如果是4个人、10个人呢。还可能出现更多的风格，这样对代码的可阅读性和可维护性都有很大的影响。最后可能导致项目无法维护（也就是维护起来费劲），所以我们需要对代码的格式进行检查。肯定不可能盯着每个人开发吧，我们需要一个工具帮我们“监视”。 这个工具进行代码检查，需要三点： 谁来检查 ？ 以什么规则检查 ？ 检查哪些文件 ？ 谁来检查 ？目前代码检查这块有几个工具 eslint, jscs, standardjs 等等。我们将要说的是 eslint。 &ensp;&ensp;&ensp;&ensp;其实使用vue官方的脚手架工具 vue-cli 生成项目是可以直接配置好 eslint 这个工具，并且在开发时会实时的检测你的代码风格，在风格有问题的时候直接在页面上显示错误信息。其实我觉得这个没太必要，想临时 debug 修改一下代码还要修改代码风格，着实有点麻烦。如果已经生成了想禁用就修改下 config/index.js 配置文件的 useEslint: false。 以什么规则检查 ？在项目中执行 eslint 的命令的时候，会默认查找当前项目根目录下面有没有.eslint.js/.eslint.json/.eslintrc 这几个配置文件。可以在其中配置对应的规则，后面说。 检查哪些文件 ？其实项目中我们只需要检查业务逻辑代码，比如 node_modules、build、dist里面的代码是不需要检查的。我们可以在项目根目录新建 .eslintignore 文件。内容举例： 1234/build//config//dist//*.js 为啥用 eslint&ensp;&ensp;&ensp;&ensp;新开项目参与人数比较多（大约10人）。打开公司以前的老项目，密密麻麻。看代码的心情都没了。大家有各自的代码风格可以理解，但是不好的风格还是不要了。所以不希望项目越走越远而造成无法维护（至少不是因为代码风格）。 如何用 eslint如何用 eslint 以达到以我们想要效果。配置 eslint 的规则（想要的结果）来进行代码检查。先看下 eslint 的配置文件： 1234567891011121314151617181920212223242526272829// https://eslint.org/docs/user-guide/configuringmodule.exports = &#123; root: true, parserOptions: &#123; parser: 'babel-eslint' &#125;, env: &#123; browser: true, &#125;, extends: [ // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules. 'plugin:vue/essential', // https://github.com/standard/standard/blob/master/docs/RULES-en.md 'standard' ], // required to lint *.vue files plugins: [ 'vue' ], // add your custom rules here rules: &#123; // allow async-await 'generator-star-spacing': 'off', // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off' &#125;&#125; 主要就是 extends 字段继承预置规则和 plugins 字段使用插件。配置文件上指明了两个规则: Extends-&gt;standard 版本：11.0.0npm: eslint-config-standard官方网站: https://standardjs.com/readme-zhcn.html 除了 standard 预置配置还有: eslint-config-airbnb eslint-config-react-app eslint-config-prettier等 &ensp;&ensp;&ensp;&ensp;当然，如果预置的规则不适用或者单纯的不喜欢，那你可以在 rule字段进行自定义配置。具体配置可参考，官方文档、Eslint 从入门到放弃 12345678910111213141516171819// 自定义配置module.exports = &#123; rules: &#123; // 关闭规则 'no-debugger': 'off', // warn 'no-debugger': 'warn', // error 'no-debugger': 'error', // 如果有配置 'tabs': [ 'error', // 检查类型 'tab', // 设置 &#123; SwitchCase: 1 // 相关配置 &#125; ] &#125;&#125; Plugins-&gt;vue 版本：4.5.0npm: eslint-plugin-vue文档: https://www.npmjs.com/package/eslint-plugin-vue Extends 字段只要设置后即可，但是 eslint-plugin-vue 设置后面有个选项，是用来配置检查代码风格的严格度： base: 设置和规则以启用正确的ESLint分析 essential: 同上，加上防止错误或意外行为的规则 strongly-recommended: 同上，加上可以显着提高代码的可读性和开发体验的规则 recommended: 同上，加上社区实践的规则，以保持统一性 此插件提供了4个等级代码风格检查，后一等级在前一等级的规则上添加更多的限制。具体添加了哪些规则请查看文档。 注意：&ensp;&ensp;&ensp;&ensp; eslint-plugin-vue 插件目前支持检查 lang=&quot;html&quot; 的&lt;template&gt;，也就是说 lang=&quot;pug&quot; 检查就失效了。&lt;style&gt;标签目前也不支持。作者表示会在未来版本中添加对 &lt;template lang=&quot;pug&quot;&gt; 和 &lt;style&gt; 的代码检查支持。 eslint 跑起来边开发边检查如果在 vue-cli 生成项目的时候选择了使用 eslint 的话，保证 config/index.js 文件中的 dev.useEslint: true 则在开发过程中一直会进行代码检查。 单独检查如果想单独运行代码检查在命令行中执行： 1npm run lint lint 命令是定义在 package.json 文件中，这个是脚手架生成时配置好的。 12345&#123; "scripts": &#123; "lint": "eslint --ext .js,.vue src" &#125;&#125; 如果没有的话，手动配置一下。需要确定你已经安装了运行 eslint 的所有依赖。 Git 提交检查&ensp;&ensp;&ensp;&ensp;很多时候忙起来可能忘了检查，或者只做简单修改就不跑开发服务器了。提交前也没有用命令检查代码。那么就有可能把未检查的代码给提交到代码库中了，这个是不允许的。所以我们需要在提交代码的时候进行一下代码的检查，检查不通过则不允许提交。 git 提供了一系列的 hook，在进行 git 操作的时候的一些钩子： 1234applypatch-msg.sample pre-commit.sample prepare-commit-msg.samplecommit-msg.sample pre-push.sample update.samplepost-update.sample pre-rebase.samplepre-applypatch.sample pre-receive.sample 我们将使用的是 pre-commit 这个钩子，这个文件使用 shell 脚本写的。 不会 shell 咋办？ 不着急。npm 上有个包叫husky专门添加钩子的，他在你 commit 或 push 的时候运行 package.json 中对应的script。如： 1234567&#123; "scripts": &#123; "precommit": "npm run test", "prepush": "npm run lint", "...": "..." &#125;&#125; 比如 precommit 命令将在 commit 操作的时候运行，这样你只需要关心在 commit 的时候做什么。如果这个命令返回了 error, commit 动作将被终止。这就实现了代码检查不通过则不允许提交代码。 VScode中的eslint&ensp;&ensp;&ensp;&ensp;既然代码中各种风格问题被检查出来了，我们要一一修复不然不能提交代码了啊。一个两个凭眼睛找得累死，如果十个百个呢，得被玩儿死啊。 &ensp;&ensp;&ensp;&ensp;还好 vscode 里面有 eslint 插件帮我们做这些事，他会根据你当前打开文件夹下的配置文件来验证当前打开文件中有哪些错误。你还可以配置保存格式化代码。 1234567891011&#123; "eslint.autoFixOnSave": true, "eslint.validate": [ "javascript", // vue需要添加此配置 &#123; "language": "vue", "autoFix": true &#125; ]&#125; 这样就可以在 vscode 中实时看到错误（鼠标放到错误的红线上会显示对应的规则），并且可以保存修复错误（部分错误需要人工干预的）。使用愉快。 总结&ensp;&ensp;&ensp;&ensp;其实 eslint 的规则是符合大部分人的习惯和最佳实践。最好在写作过程中自己也养成一个良好的编码习惯，就算没有代码检查，你的代码也是看上去简洁有序，让人一目了然。这样不仅给别人一个好印象也能够相应的减少自己代码中的问题。你也不想别人维护你的代码的时候：“这tm谁写的，怎么看啊”……]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化－预加载技术]]></title>
    <url>%2F2018%2F05%2F20%2Fpre-load%2F</url>
    <content type="text"><![CDATA[原文地址当我们谈到前端的性能时，总是会提到比如合并、压缩、缓存或者在服务器上开启gzip之类的，目的都是为了让页面加载的更快。资源预拉取（prefetch）则是另一种性能优化的技术。通过预拉取可以告诉浏览器用户在未来可能用到哪些资源。 Pre-fetching会提示浏览器那些未来一定或可能使用到的资源，有时在当前页面见效，有些则在未来可能打开的页面生效。 作为开发者，我们比浏览器更懂自己的应用。我们可以利用这些技术提前告知浏览器web中用到的核心资源。 以前这种实践也被称为prebrowsing。但这并不是一种单一的技术，实际上可以拆分成很多小点：dns-prefetch, subresource, prefetch, preconnect, 和 prerender。 DNS prefetchDNS prefetching通过指定具体的URL来告知客户端未来会用到相关的资源，这样浏览器可以尽早的解析DNS。比如我们需要一个在example.com的图片或者视频文件。在&lt;head&gt;就可以这么写： 1&lt;link rel="dns-prefetch" href="//example.com"&gt; 当请求这个域名下的文件时就不需要等待DNS查询了。项目中有用到第三方的代码时这么做尤其有益（其他的使用场景，比如当静态资源和HTML不在一个域上，而在CDN上；又比如在重定向前可以加上DNS prefetch）。 Harry Roberts在他的前端性能优化文章中建议： 简单的一行就能让支持的浏览器提前解析DNS。也就是说在浏览器请求资源时，DNS查询就已经准备好了。 这可能看起来是个非常微不足道的性能提升，而且还不是必须的–Chrome总是会做类似的处理，用户只要在地址栏敲入一部分域名，如果命中了历史常用的网站，Chrome就会提前解析DNS、预拉取页面。（效果确实有限，但是聊胜于无） Preconnect和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）。用法如下： 1&lt;linkrel="preconnect"href="http://css-tricks.com" /&gt; Ilya Grigorik写了一篇文章详细说明了这种技术： 现代浏览器竭尽所能的尝试预测网站可能需要哪些链接。通过提前连接，浏览器可以提前建立必要的通信，消除了实际请求中DNS、TCP和TLS的耗时。不过，即使是只能的现代浏览器，也没办法为每个网站可靠的预测所有连接。 幸运的是开发者可以告诉浏览器哪些通信需要在实际请求发起前就提前建立连接。 举个栗子： 上半张图显示了浏览器先拉 html、再拉CSS并建立好CSSOM后，发现需要两个外链的字体（在fonts.gstatic.com`上）,然后浏览器开始发起两个请求，具体来说，需要对这个域进行DNS解析、TCP和TLS握手（一个建立后可以复用给另一个连接）。 123&lt;link href="https://fonts.gstatic.com" rel="preconnect" crossorigin /&gt;&lt;link href="https://fonts.googleapis.com/css?family=Roboto+Slab:700|Open+Sans" rel="stylesheet" /&gt; 下半张图增加了上面的代码来从fonts.gstatic.com preconnect资源。可以看到，浏览器在请求CSS的同时并行的建立字体资源需要的连接，等到真正开始需要字体时立刻就开始返回数据。 更多详细的内容可以参考Ilya Grigorik的文章。 目前只支持Firefox 39+和Chrome 46+，具体参见caniuse Prefetch当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用。prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。 1&lt;link rel="prefetch" href="image.png" /&gt; 不同于DNS prefetch，上面的写法可是会去请求、下载资源并且缓存起来。当然也是有一些发生条件的。比如，客户端可能会在弱网络下不去请求较大的字体文件，Firefox则只会在浏览器空闲的时候prefetch资源（译者注：这里是MDN上对浏览器空闲的定义和一些FAQ，建议阅读）。 正如Bram Stein在他的文章中指出，prefetch很适用于优化webfonts的性能。以前，字体文件必须等DOM和CSSOM创建好后才能下载，可如果prefetch了字体，这个瓶颈就能轻松解决了。 注意：prefetch并没有同域的限制 Subresourcesubresource可以用来指定资源是最高优先级的。比如，在Chrome和Opera中我们可以加上下面的代码： 1&lt;link rel="subresource" href="styles.css" /&gt; Chromium的文档这么解释： 和&quot;Link rel=prefetch&quot;的语义不同，&quot;Link rel=subresource&quot;是一种新的连接关系。rel=prefetch指定了下载后续页面用到资源的低优先级，而rel=subresource则是指定当前页面资源的提前加载。 所以，如果资源是在当前页面需要，或者马上就会用到，则推荐用subresource，否则还是用prefetch。 Prerenderprerender是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。 1&lt;link rel="prerender" href="/thenextpage.html"/&gt; Steve Souders的文章详细解释了这个技术： prerender就像是在后台打开了一个隐藏的tab，会下载所有的资源、创建DOM、渲染页面、执行JS等等。如果用户进入指定的链接，隐藏的这个页面就会进入马上进入用户的视线。Google Search多年前就利用了这个特性实现了Instant Pages功能。微软最近也宣布会让Bing在IE11上用类似prerender的技术。 但是要注意，一定要在十分确定用户回点某个链接时才用这个特性，否则客户端就会无端的下载很多资源和渲染这个页面。 正如任何提前的动作一样，预判总是有一定风险出错。如果提前的动作是昂贵的（比如高CPU、耗电、占用带宽），就要谨慎使用了。虽然不容易预判用户会点进哪个页面，但还是存在一些典型的场景： 如果用户搜索到了一个明显正确的结果时，那么这个页面就很有可能被点入 如果用户在登录页面，那么登录成功后的页面就很可能接下来会被加载了 如果用户在阅读一个多页面的文章或者有页码的内容时，下一页就很可能会马上被点击了 利用Page Visibility API可以用来防止页面在还没真正展示给用户时就触发了JS的执行。 未来：Preload以上是已有的技术，我们再谈谈未来。preload草案建议允许始终预加载某些资源，不像prefetch有可能被浏览器忽略，浏览器必须请求preload标记的资源。 1&lt;link rel="preload" href="image.png" /&gt; 然而，这项草案还没有任何浏览器支持，不过值得关注。 总结预判用户的操作虽然不易，而且还需要大量的设计和测试工作，但是性能的提升是值得我们孜孜不倦的去追求的。如果我们愿意试验这些预加载技术，我们肯定能显著地提升用户体验。 （译者补一句，文章说的大部分预加载技术移动端都不支持，PC支持有限，但我们显然应该知道这些技术的存在，并且持续的关注） 扩展阅读: Slides from a talk by Ilya Grigorik called Preconnect, prerender, prefetch MDN link prefetching FAQ W3C preload spec Harry Roberts on DNS prefetching HTML5 prefetch Preload hints for webfonts]]></content>
      <tags>
        <tag>前端</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS使用Github第三方登录[OAuth]]]></title>
    <url>%2F2017%2F01%2F18%2Flogin-with-github%2F</url>
    <content type="text"><![CDATA[说起来真是糟心，国内的三方登录大部分都是比较规范的oAuth。但是恶心就恶心在如果正式使用，网站必须有备案。唉，算了，看来也只有国外的没这个变态的要求了。 在 Github 上注册一个APP打开 Github 上个人 Setting 这个中间改过版本，之前名字是applications```了。1234567891011点进去新建一个app然后填写对应的信息，这里不再赘述。# 在网站上配置授权登录开始## 1、进入授权链接构建```shell# 请求URLhttps://github.com/login/oauth/authorize 参数名 类型 值 client_id String 注册App时官方分配的 redirect_uri String 用户授权后带着code跳转的链接地址(如：http://www.woolson.cn/github/callback) scope String 控制需要获取权限的范围，具体看API，第三方登录的这里就不用传这个参数就行了 state String 这参数会在Github重定向的时候带着，用来判断获取信息请求是否被其他人拦截返回，可随机生成一段 12# 构建下面这个样链接https://github.com/login/oauth/authorize?client_id=$&#123;client_id&#125;&amp;redirect_uri=$&#123;redirect_uri&#125;&amp;state=$&#123;state&#125; 可在前端放置一枚按钮，直接 到此链接，然后会跳转至Github的授权页授权12345678910## 后端处理获取用户信息用户授权后跳转至 ```redirect_uri``` 后端路由处理拿到的 ```code``` 换取 ```access_token```(获取用户信息关键)code会带在```redirect_uri```后面，使用路由中 ```request.query.code``` 获取`http://www.woolson.cn/github/callback?code=*****&amp;state=*****`下面用 ```code``` 获取 ```access_token 我直接使用 NodeJS 的 Request 模块直接后端操作，so redirect_uri就不用了 12# 请求URLhttps://github.com/login/oauth/access_token 参数名 类型 值 client_id String 注册App时官方分配的 client_secret String 注册App时官方分配的 code String 刚刚那个code state String 在第一步中带的state，现在继续带上(其实不带入也可以的) 用 发送请求拿 ```token```12345678910111213```javascriptconst param = &#123; url: &quot;https://github.com/login/oauth/access_token&quot;, client_id: &quot;&#123;client_id&#125;&quot;, client_secret: &quot;&#123;client_secret&#125;&quot;, code: req.query.code,&#125;request(fetchUrlwithParams(param), (err, response, body) =&gt; &#123; body = JSON.parse(body) body.access_token // 这个就是需要拿到的token&#125;) 用 获取 ```user``` 的信息12345&gt; 注意：需要在请求中加入请求头 ```User-Agent``` 并且值为你APP的名称```shell# 请求URLhttps://api.github.com/user 参数名 类型 值 access_token String 只需要带上上一步返回的access_token即可 12345678910111213if(body.access_token) &#123; const param = &#123; url: "https://api.github.com/user?access_token=" + body.access_token, headers: &#123; "User-Agent": "app name", &#125; &#125; request(param, (err, response, body) =&gt; &#123; body = JSON.parse(body) if(!body.message) insertGithub(req, res, body) else res.redirect("/study") &#125;)&#125;else res.redirect("/") 如上，如果获取用户信息失败，会在返回信息中带有 字段。获取正常，存储用户信息；获取失败，重定向到网站首页。12345678910## 存储用户信息和种cookie&gt; 1、这一步是为啥呢，因为不可能每次打开网站都进行一次授权。小网站做登录有点矫情。&gt; 2、保存用户信息。怕保存数据量太大，对需要的信息保存一下。（本网站没保存任何敏感信息，只有名称和Github主页）&gt; 3、种植cookie，在浏览器中种上类似于ID的东西，用户访问就带上，类似于记住我的功能一样。等过期了，再让用户授权一次。可以使用Mongodb，进行数据保存，这里不做赘述。种植 ```cookie``` 就是在重定向到网站的时候在 ```Response``` 中带上 ```cookie 123456789101112const param = &#123; domain: ".woolson.cn", maxAge: 5184000000, httpOnly: false, secure: false, path: "/",&#125;user.save((err, docs) =&gt; &#123; res.cookie("user", hashs.nameHash, param) res.redirect("/study")&#125;) 种上cookie以后就是取 Nodejs 需要在App上使用 [```cookie-parser```](https://github.com/expressjs/cookie-parser) Like this:1234```javascriptimport cookieParser from &quot;cookie-parser&quot;app.use(cookieParser()) 然后在以后的请求中获取 123456789&gt; 在保存的时候种的cookie，里面带有你用户的ID用来取用户信息的。```javascriptapp.get(&quot;/oauth/login&quot;, (req, res) =&gt; &#123; const userID = req.cookies.user if(userID) getLoginUser(req, res) else jsonWrite(res)&#125;) 这样就能拿到信息啦……其实后面说的都比较简单，具体实现可以根据实际情况。]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在NodeJS中使用markdown-js模块解析md文件]]></title>
    <url>%2F2016%2F08%2F01%2Fmd-in-nodejs%2F</url>
    <content type="text"><![CDATA[首先是安装markdown-js模块 npm install markdown-js 在路由文件中定义所要访问的文章路径12345678910111213141516171819202122232425var markdown = require("markdown-js")app.param("article_name", (req, res, next, name) =&gt; &#123; let filePath, content, html filePath = `/static/articles/$&#123;name&#125;.md` // 判断文件是否存在（不存在的文件会报错，也可以用fs模块进行判断） try &#123; content = fs.readFileSync(filePath, "utf8") &#125; catch (e) &#123; content = "Author had removed this article, Sorry!" &#125; // 利用markdown-js模块将MD解析成HTML html = markdown.makeHtml(content) // 这里的formatHTML是用来加入header和一些自定义的脚本和CSS样式, 然后返回 // 在header里面会加入Highlight.js将代码高亮 res.send(formatHTML(name, html)) next()&#125;)app.get("/articles/:article_name", (req, res) =&gt; &#123; res.end()&#125;) 现在如果运行正常，即可看出来是这样的 使用Highlight.js格式化代码 这个是Highlight官网 https://highlightjs.org/ 该网站可能需要翻墙才能访问 我放了个在自己的服务器上 Highlight.zip 使用方法 在导出的HTML的head中引入下载的包中的CSS和JS，压缩包中都有的引入JS是分析代码高亮的，CSS则是用来代码高亮的，里面有很多种主题可以选择使用 123&lt;link rel="stylesheet" href="./monokai.css"&gt;&lt;script src="./highlight.pack.js"&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; 这里我贴一个Monokai主题 现在代码是好看了，细心的盆友会发现区块和其他部分还是无样式，挺难看的所以我又引入了马克飞象的样式文件，也可以自己写。CSS链接在此 https://dn-maxiang.qbox.me/res-min/themes/marxico.css 所有现在好看多了(还有很多东西，自己去发现吧)…… 对了推荐一个丁老师写的图床chrome插件(用过的都说好O(∩_∩)O哈哈~)图床on微博]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置ssh的config文件实现多秘钥管理]]></title>
    <url>%2F2016%2F08%2F01%2Fssh-config%2F</url>
    <content type="text"><![CDATA[前些天在看各位大牛的 Github 发现他们 Github 的 Contribution 基本上绿油油的一片，甚是好看。然后我看了下自己的 Github……空白上几个小绿点……我想了想，真是日了**了，我也没少往G上填代码啊，咋都空白的呢。然后看了下G官方对 Contribution 规则的介绍。其他的条件我就不说了，我的问题在于我电脑里面的ssh秘钥是公司的，用的公司邮箱，不是我自己Github邮箱，所以提交了代码不算Contribution。我需要在公司用公司的秘钥，github上用自己的邮箱。 直接操作（ 我用的是MacOS ）因为使用了多秘钥，每个秘钥的邮箱是不一样的，所以要取消掉全局的账户设置 12git config --unset --global user.namegit config --unset --global user.email 首先你肯定有几个秘钥对放在/User/**/.ssh/目录下…如果没有的话，可以现在生成。先把已有的修改名称： -t rsa -C "woolson.lee@gmail.com"```123456789101112131415![文件目录](http://ww1.sinaimg.cn/large/708e7d29gw1fagaptmi6dj21040fwwkk.jpg)看下里面会有两个id_rsa秘钥对，名字完全可以随意。&gt; 在生成秘钥后，需要执行```ssh-add id_rsa```添加刚刚生成的秘钥 &gt; 但是，这样只是添加秘钥到ssh的sesison中，电脑重启后ssh就session就失效了，还需要再添加一次。 &gt; 查询之后，找到一个永久添加的方法即: ```ssh-add -K id_rsa```。# 新建修改~/.ssh/config文件如果之前没有类似操作过，```.ssh/```目录下可能没有config文件新建一个新的即可```touch config 添加下面的内容到config文件中 1234567891011#default githubHost github.com // 这个是个命名，请随意 HostName github.com // 这个可以是IP也可以是域名 PreferredAuthentications publickey // 指定登录方式 IdentityFile ~/.ssh/id_rsa // 指定秘钥文件Host github_work_13 HostName 192.168.0.13 User root PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_work 配置完成，可以测试是否可以正常使用配置好以后可以使用123456789如果不行的话，可以尝试重启一下```ssh```的服务。可以使用命令行...```shell#开启sudo systemsetup -setremotelogin on#关闭sudo systemsetup -setremotelogin off 之前我们取消了全局的设置，需要到你的代码库中设置局部的用户名和邮箱，然后再推送的话就是你设置的用户了]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-router 2.X 中使用browserHistory]]></title>
    <url>%2F2016%2F07%2F21%2Freactrouter-history%2F</url>
    <content type="text"><![CDATA[之前开发一直都有使用react-router。使用的hashHistory（看上去有点丑，不简洁）。因为项目都不是SPA的，所以没遇到什么坑。但是现在呢，公司一个SPA项目需要后端Redirect URL，hashHistory就不方便了。于是准备使用browserHistory。先看了下官方的Historise。还是蛮简单明了的。 实现的原理就是后端服务器除了API其他的路由访问都返回index.html，路由匹配交给前端啦 我们先从前端切入吧，前端配置比较简单。 先把前端的1234567```javascriptimport &#123; Router, Route, browserHistory &#125; from &quot;react-router&quot;const RootRounter = &lt;Router history=&#123; browserHistory &#125;&gt; &lt;Route path=&quot;/&quot; component=&#123; App &#125;&gt;&lt;/Route&gt;&lt;/Router&gt;这个时候如果你用webpack-dev-server的话，需要在开启测试服务的命令后面加上123456789# 在Nodejs后端服务中配置直接亮配置吧```javascriptapp.get(&quot;*&quot;, (req, res) =&gt; &#123; res.sendFile(path.resolve(__dirname, &quot;./index.html&quot;))&#125;) 这个配置需要放在其他路由或者后端API的后面，不然的话会造成前端访问API无法正确拿到数据可以在前端路由中加入通配符匹配不存在的路径显示404页面，增加体验 在Tomcat后端服务中配置其实说实话我不懂Tomcat，原因是公司项目中使用的是Tomcat。公司同事很配合得和我一起配置弄好了。 其实也是在后端的路由中也是类似Nodejs的处理，后端JAVA使用的是JFinal框架。处理呢就是在匹配不到路由的时候render Tomcat中指定的项目根目录的index.html 在配置JAVA之前我Google了一下别人的配置，很多人使用了官方介绍的方法。 先在nginx中加入一下配置 123456server &#123; ... location / &#123; try_files $uri /index.html; &#125;&#125; 在项目根目录中新加1234567```shellRewriteBase /RewriteRule ^index\.html$ - [L]RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule . /index.html [L] 但是呢貌似没啥作用，最后修改的还是render(&quot;./index.html&quot;)解决问题的 如果配置确认无误后，访问你的项目即可看到清爽的URL咯。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
